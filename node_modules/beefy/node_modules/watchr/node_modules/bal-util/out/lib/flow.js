// Generated by CoffeeScript 1.6.2
var TaskGroup, balUtilFlow, eachr, typeChecker,
  __slice = [].slice;

TaskGroup = require('taskgroup').TaskGroup;

typeChecker = require('typechecker');

eachr = require('eachr');

balUtilFlow = {
  wait: function(delay, fn) {
    return setTimeout(fn, delay);
  },
  extractOptsAndCallback: function(opts, next, config) {
    var completionCallbackName, _i, _len, _ref, _ref1;

    if (config == null) {
      config = {};
    }
    if ((_ref = config.completionCallbackNames) == null) {
      config.completionCallbackNames = ['next'];
    }
    if (typeChecker.isFunction(opts) && (next != null) === false) {
      next = opts;
      opts = {};
    } else {
      opts || (opts = {});
    }
    if (!next) {
      _ref1 = config.completionCallbackNames;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        completionCallbackName = _ref1[_i];
        next = opts[completionCallbackName];
        if (next) {
          break;
        }
      }
    }
    next || (next = null);
    return [opts, next];
  },
  flow: function() {
    var action, actions, args, next, object, tasks, _ref, _ref1, _ref2;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (args.length === 1) {
      _ref = args[0], object = _ref.object, actions = _ref.actions, action = _ref.action, args = _ref.args, tasks = _ref.tasks, next = _ref.next;
    } else if (args.length === 4) {
      _ref1 = args, object = _ref1[0], action = _ref1[1], args = _ref1[2], next = _ref1[3];
    } else if (args.length === 3) {
      _ref2 = args, actions = _ref2[0], args = _ref2[1], next = _ref2[2];
    }
    if ((action != null) === false && (actions != null) === false) {
      throw new Error('balUtilFlow.flow called without any action');
    }
    if (actions == null) {
      actions = action.split(/[,\s]+/g);
    }
    if (object == null) {
      object = null;
    }
    tasks || (tasks = new TaskGroup().once('complete', next));
    actions.forEach(function(action) {
      return tasks.addTask(function(complete) {
        var argsClone, fn;

        argsClone = (args || []).slice();
        argsClone.push(complete);
        fn = typeChecker.isFunction(action) ? action : object[action];
        return fn.apply(object, argsClone);
      });
    });
    tasks.run();
    return this;
  },
  createSnore: function(message, opts) {
    var snore, _ref;

    opts || (opts = {});
    if ((_ref = opts.delay) == null) {
      opts.delay = 5000;
    }
    snore = {
      snoring: false,
      timer: setTimeout(function() {
        snore.clear();
        snore.snoring = true;
        return typeof message === "function" ? message() : void 0;
      }, opts.delay),
      clear: function() {
        if (snore.timer) {
          clearTimeout(snore.timer);
          return snore.timer = false;
        }
      }
    };
    return snore;
  },
  suffixArray: function() {
    var arg, args, item, result, suffix, _i, _j, _len, _len1;

    suffix = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    result = [];
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      if (!typeChecker.isArray(arg)) {
        arg = [arg];
      }
      for (_j = 0, _len1 = arg.length; _j < _len1; _j++) {
        item = arg[_j];
        result.push(item + suffix);
      }
    }
    return result;
  }
};

module.exports = balUtilFlow;
